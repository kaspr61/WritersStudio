package com.team34.model.event;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;

import com.team34.model.UIDManager;

/**
 * This class manages all events and event order lists.
 * <p>
 * The events are stored in a HashMap, with UIDs (Long) as keys.
 * <p>
 * Event order lists are lists of event UID in a specific order. This allows switching
 * between different event orders and editing the order on a specific order list.
 *
 * @author Kasper S. Skott
 */
public class EventManager {

    private HashMap<Long, Event> events;
    private ArrayList<LinkedList<Long>> eventOrderLists;
    private boolean hasChanged;

    /**
     * Constructs and initializes the EventManager. Creates a default event order list at index 0.
     */
    public EventManager() {
        hasChanged = false;
        events = new HashMap<Long, Event>();
        eventOrderLists = new ArrayList<>();
        eventOrderLists.add(new LinkedList<Long>());
    }

    /**
     * Constructs a new event and stores it. The new event UID is generated by the {@link UIDManager},
     * and is thereafter placed at the back of each event order list.
     * This will set {@link EventManager#hasChanged} to true, as data has been changed.
     * @param name the name of the event
     * @param description the description of the event
     * @return the UID of the new event
     */
    public long newEvent(String name, String description) {
        long uid = UIDManager.nextUID();
        addEvent(uid, name, description);

        if(eventOrderLists.size() < 1)
            eventOrderLists.add(new LinkedList<>());

        for(LinkedList<Long> e : eventOrderLists)
            e.add(uid);

        return uid;
    }

    /**
     * Edits the data inside the event associated with the given UID.
     * This will set {@link EventManager#hasChanged} to true, as data has been changed.
     * @param uid the UID associated with the event to edit
     * @param name the new name
     * @param description the new description
     * @return true if the event was successfully edited; false if the edit failed.
     */
    public boolean editEvent(long uid, String name, String description) {
        if(events.containsKey(uid)) {
            events.replace(uid, new Event(name, description));
            hasChanged = true;
            return true;
        }
        return false;
    }

    /**
     * Removes the event associated with the given UID.
     * Also removes the UID from each order list, and the UIDManager.
     * This will set {@link EventManager#hasChanged} to true, as data has been changed.
     * @param uid the UID of the event to remove
     */
    public void removeEvent(long uid) {
        events.remove(uid);
        UIDManager.removeUID(uid);

        for(LinkedList<Long> e : eventOrderLists)
            e.remove(uid);

        hasChanged = true;
    }

    /**
     * Creates an event, bypassing the UIDManager, and does not add the UID to
     * any event order list.
     * Note: This should only be used when loading a project, since events and
     * event order lists are loaded separately
     * This will set {@link EventManager#hasChanged} to true, as data has been changed.
     * @param uid the UID to associate with the event
     * @param name the name of the event
     * @param description the description of the event
     */
    public void addEvent(long uid, String name, String description) {
        events.put(uid, new Event(name, description));
        hasChanged = true;
    }

    /**
     * Returns a structure of data contained within the event, specified with the given UID.
     * The data returned is formatted like this:
     * <ul>
     *  <li>data[0] -- name
     *  <li>data[1] -- description
     * </ul>
     * @param uid the UID of the event to get data from
     * @return an array with a constant size of 2
     */
    public Object[] getEventData(long uid) {
        Object[] data = new Object[2];
        Event event = events.get(uid);
        data[0] = event.getName();
        data[1] = event.getDescription();

        return data;
    }

    /**
     * Returns a structure which contains all data within every event.
     * <p>
     * The data returned is formatted like this:
     * <ul>
     *  <li>data[i] -- array of event data
     *  <ul>
     *      <li>data[i][0] -- UID
     *      <li>data[i][1] -- name
     *      <li>data[i][2] -- description
     *  </ul>
     * </ul>
     * <p>
     *
     * Example of contents:
     * <ul>
     *     <li>data[0][0] -- 1997L
     *     <li>data[0][1] -- "The Beginning"
     *     <li>data[0][2] -- "This is where it all began"
     *     <li>data[1][0] -- 2020L
     *     <li>data[1][1] -- "The End"
     *     <li>data[1][2] -- "This is where it all ended"
     * </ul>
     * <p>
     *
     * Note: The data returned is unordered.
     *
     * @return a 2-dimensional array of event data
     */
    public Object[][] getEvents() {
        if(events.size() < 1)
            return null;

        Long[] uidOrder = events.keySet().toArray(new Long[events.size()]);
        Object[][] eventArray = new Object[uidOrder.length][3];

        for (int i = 0; i < uidOrder.length; i++) {
            long uid = uidOrder[i];
            Event eventRef = events.get(uid);
            eventArray[i][0] = uid;
            eventArray[i][1] = eventRef.getName();
            eventArray[i][2] = eventRef.getDescription();
        }
        return eventArray;
    }

    /**
     * Returns an array of UIDs, specifying the order of events according
     * to the list at the specified index. Provides boundary-checking.
     * @param eventOrderList the index to the event order list to use
     * @return the order of event UIDs
     */
    public Long[] getEventOrder(int eventOrderList) {
        if(eventOrderLists == null)
            return null;
        if(eventOrderList >= eventOrderLists.size() || eventOrderList < 0)
            return null;

        return eventOrderLists.get(eventOrderList).toArray(
                new Long[eventOrderLists.get(eventOrderList).size()]
        );
    }

    /**
     * Returns the index of a given event in a given event order list, else returns -1.
     *
     * @author Jim Andersson
     * @param uid event
     * @return event index
     */
    public int getEventIndex(int eventOrderList, long uid) {
        Long[] events = getEventOrder(eventOrderList);

        for (int i = 0; i < events.length; i++) {
            if (events[i].equals(uid))
                    return i;
        }
        return -1;
    }

    /**
     * Swap the place of two events on the timeline.
     *
     * @author Jim Andersson
     * @param orderList The order list on which the two events appear.
     * @param index1 index of event on the list
     * @param index2 index of event on the list
     */
    public void swapEvent(int orderList, int index1, int index2) {
        //TODO swap places between two events in the specified order list.
        Long[] order = getEventOrder(orderList);

        Long temp = order[index2];
        order[index2] = order[index1];
        order[index1] = temp;

        for (int i = 0; i < eventOrderLists.get(orderList).size(); i++) {
            eventOrderLists.get(orderList).set(i, order[i]);
        }
        hasChanged = true;
    }

    /**
     * Move event from one spot on the timeline to another.
     *
     * @author Jim Andersson
     * @param orderList The event list on which the given event appears
     * @param fromIndex The dragged event which has been selected through MouseEvent
     *                  (see {@link com.team34.view.timeline.Timeline})
     * @param toIndex The event on which the dragged event is released
     */
    public void moveEvent(int orderList, int fromIndex, int toIndex) {

        Long[] order = getEventOrder(orderList);


        // When the event is moved in the right direction on the timeline,
        // the events inside the scope of the loop are shifted to the left.
        if (fromIndex < toIndex) {
            for (int i = fromIndex; i < toIndex; i++) {
                Long temp = order[i];
                order[i] = order[i+1];
                order[i+1] = temp;
            }
        }

        // When the event is moved in the left direction on the timeline,
        // the events inside the scope of the loop are shifted to the right.
        if (toIndex < fromIndex) {
            for (int i = fromIndex; i > toIndex; i--) {
                Long temp = order[i];
                order[i] = order[i - 1];
                order[i - 1] = temp;
            }
        }

        for (int i = 0; i < eventOrderLists.get(orderList).size(); i++) {
            eventOrderLists.get(orderList).set(i, order[i]);
        }
        hasChanged = true;
    }

    /**
     * Adds an event order list.
     * This should only be used when loading a project.
     * @param orderList the event order list to add
     */
    public void addOrderList(LinkedList<Long> orderList) {
        eventOrderLists.add(orderList);
    }

    /**
     * Removes all events and event order lists, and sets {@link EventManager#hasChanged} to false.
     */
    public void clear() {
        events.clear();
        eventOrderLists.clear();
        hasChanged = false;
    }

    /**
     * Returns whether the data inside this class has changed
     * @return the value of {@link EventManager#hasChanged}
     */
    public boolean hasChanged() {
        return hasChanged;
    }

    /**
     * Sets {@link EventManager#hasChanged} to false.
     */
    public void resetChanges() {
        hasChanged = false;
    }

}
